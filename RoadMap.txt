
Project summary:

UI Components (React)
	•	Login/Register Page
	•	Dashboard
	◦	View upcoming sessions
	◦	Join/Start session buttons
	•	Mentor Listing Page
	◦	Filters, profiles, book session
	•	Video Call Room
	◦	Video stream (self + remote)
	◦	Chat panel
	◦	Timer
	◦	End Call button
	•	Post-session Feedback Modal



Backend Architecture (Spring Boot)
	•	UserController: Signup, Login, Role-based auth (JWT)
	•	SessionController: Bookings, scheduling, history
	•	WebSocketController: Signaling for WebRTC (offer/answer/ICE exchange)
	•	FeedbackController: Store ratings/comments
	•	SecurityConfig: JWT filters + CORS config



Database Schema (PostgreSQL)
users
	•	id, name, email, password, role (MENTOR / MENTEE), bio, skills, etc.
sessions
	•	id, mentor_id, mentee_id, start_time, end_time, status
feedback
	•	id, session_id, rating, comments


WebRTC Signaling Flow
	1	Mentee clicks “Join Call”
	2	WebSocket connection opens with Spring Boot
	3	Mentee sends offer SDP
	4	Server relays to Mentor
	5	Mentor sends answer SDP
	6	ICE candidates exchanged via WebSocket
	7	Media flows peer-to-peer over WebRTC



---- High-Level Architecture ----

WebRTC handles the peer-to-peer media streaming.

WebSocket via Spring Boot is used for signaling (exchanging session descriptions and ICE candidates).

React handles the UI and WebRTC logic on the client side.



Video streaming detailed roadmap

1. React (Client Side)
	a. UI Setup
	   Display two video elements: local and remote.
	   Buttons: “Join Call”, “Hang Up”.

	b. Media Setup
	   Use navigator.mediaDevices.getUserMedia() to access webcam/mic.
	   const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
	   localVideoRef.current.srcObject = localStream;
	c. WebRTC Setup
	   Create RTCPeerConnection.
	   Add local stream tracks to peer connection.
	   Handle ICE candidate generation and track addition.
	d. WebSocket Setup
	   Connect to Spring Boot WebSocket endpoint using WebSocket or Socket.IO.
	   On “Join Call”:
			Create offer SDP.
			Send to server via WebSocket.
	   On receiving answer SDP or ICE candidate:
			Set remote description.
			Add remote ICE candidate.

2. Spring Boot (Backend Signaling Server)
	a. WebSocket Setup
	   	Use @ServerEndpoint or Spring’s @MessageMapping with STOMP over WebSocket.
	   	Maintain mapping of connected users (e.g., Map<String, WebSocketSession>).
	b. Message Routing
		Handle different message types:
		{
		"type": "offer",
		"from": "mentee",
		"to": "mentor",
		"sdp": "..."
		}

		Backend logic:
		Receive offer from mentee.
		Relay to the mentor (via stored WebSocket session).
		Same for answer and ICE candidates.
    c. Example Controller
		@MessageMapping("/signal")
		@SendToUser("/topic/receive")
		public SignalMessage handleSignal(SignalMessage message) {
			// Route to appropriate user
		}

Use TURN/STUN servers to ensure connectivity behind NAT (e.g., Google STUN: stun:stun.l.google.com:19302).
Consider using Socket.IO or Spring Messaging with STOMP for more structured WebSocket messaging.
Keep user IDs/session IDs for routing.



